/***************************************************************************
                          main.cpp  -  description
                             -------------------
    begin                : Fri Nov 25 2011
    copyright            : (C) 2011 by Pavlin Mavrodiev
    email                : pmavrodiev@ethz.ch
 ***************************************************************************/


#include "base.h"

#include <iostream>
#include <string>
#include <stdlib.h>
#include <stdio.h>
#include <cmath>
#include <algorithm>

#include <dranxor.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_statistics_double.h>


using namespace std;
using namespace CTGlobal;

double *estimates; //store estimates at time t
double *initial_estimates; //store initial estimates
FILE *inFile=NULL; //read in the initial estimates

/*gracefully exit by closing all open file handles, freeing memory, etc.*/
void grace_exit() {
  if (estimates != NULL) free(estimates);
  if (initial_estimates != NULL) free(initial_estimates);
  if (inFile != NULL) fclose(inFile);
  exit(1);
}

/*read "filename" from base.ct containing the initial estimates*/
void read_initial_estimates() {
  using namespace CTGlobal;  
  double estimate=0;
  int counter = 0;
  estimates = (double *) calloc(N,sizeof(double));
  if (estimates==NULL)
    perror("read_initial_estimates(): failed to allocate memory to estimates\n");
  initial_estimates = (double *) calloc(N,sizeof(double));
  if (initial_estimates==NULL)
    perror("read_initial_estimates(): failed to allocate memory to initial_estimates\n");
   inFile = fopen(filename.c_str(),"r");
  if (inFile == NULL) perror("read_initial_estimates():");
  
  while ((fscanf(inFile,"%lf",&estimate) == 1) && (counter<N)) {
    estimates[counter] = estimate;
    initial_estimates[counter++] = estimate;
  }
  
  if (counter<N) { //fewers estimates in the input file than we expected from base.ct
    printf("read_initial_estimates(): Expected %d estimates from base.ct but got only %d from %s\n",N,counter,filename.c_str());
    grace_exit();
  }
  fclose(inFile);
}


int main(int argc, char *argv[])
{
 
  initialize_program( argc,  argv );
  read_initial_estimates();
  double collective_error = 0;
  double group_diversity = 0;
  double woc=0;
  /* Euler: x_i(t+1)=x_i(t)+deltat*delta_i_t */
  double delta_i_t=0;mean=0;
  /* loop over the whole time period*/
  for (long i=0; i<t; i++) {
    
  }
  
  /*calculate the final collective error and group diversity*/
  /*log of the estimates. how much I miss R's vectorization */
  double *dummy = (double *) malloc(N*sizeof(double));
  for (unsigned j=0; j<N; j++) 
    dummy[j] = log(estimates[j]);

  double mean=gsl_stats_mean(dummy,1,N);
  collective_error = pow(lnTruth-mean,2);
  group_diversity =  gsl_stats_variance_m(dummy,1,N,mean);
  free(dummy);

  /*calculate the final WOC indicator*/
  sort(&estimates[0], &estimates[N]);
  int start = ceil(N/2);
  while (start > 1) {
    if ((estimates[start-1] <= exp(lnTruth)) && (estimates[N-start] >= exp(lnTruth))) {
      woc = (double) start;
      break;
    }	 	
    start--;
  }
  /***************/

  std::cout << collective_error << "\t";
  std::cout << group_diversity << "\t";
  std::cout << woc << std::endl;

  free(estimates);
  free(initial_estimates);  
  return EXIT_SUCCESS;
  
}


